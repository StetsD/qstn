js-01
// Ошибка!
// Здесь say = person.say сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет this.

// Для работы вызовов типа person.say(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.

// Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.

// Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:
//
// base – это объект.
//   name – это имя свойства объекта.
//   strict – это режим исполнения. Является true, если действует строгий режим (use strict).
// Результатом доступа к свойству person.say является не функция, а значение ссылочного типа. Для person.say в строгом режиме оно будет таким:

js-02
// number, object

js-03
// нельзя менять отдельный символ в строке, можно лишь создать новую строку

js-04
// 1 2 запишутся но их результаты будут проигнорированны ПРОВЕРИТЬ
// проверить с Promise.allSettled

js-05
Мы изменяем только значение переменной person, а не первый элемент в массиве, поскольку этот элемент имеет другую (скопированную) ссылку на объект.
Первый элемент в членах по-прежнему содержит ссылку на исходный объект. \
Когда мы регистрируем массив элементов, первый элемент по-прежнему содержит значение объекта, которое регистрируется.